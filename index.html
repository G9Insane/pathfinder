<html>
<head>
<title>MapMaker</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<!-- Bootstrap -->
<link href="css/bootstrap.min.css" rel="stylesheet" media="screen">
<script src="js/jquery-1.10.2.min.js"></script>
<script type="text/javascript" src="js/raphael-min.js"></script>

<script language='javascript'>
/* behaviour:
if mouse is double-clicked in map: make a circle, 
- when moouse moves from click, make a line
- with each click, drop a new circle, with line ending at that circle, and starting a new line
- unless a circle is already there. in which case, connect the line to the existing circle, and keep going
- stop this mode when mouse is double-clicked.
-- if double-clicked on a circle, end line on that circle
-- if double-clicked in empty space, destroy that last line.
- drag on circle to move it. 
- click on circle to select
-- 'd' deletes selected circle, and all connected lines
- click on line to select it
-- 'd' deletes selected line


*/
$( document ).ready(function() {
  	var imageurl = "metmap_fl1.png";
  	var srcWidth = 3214;
  	var srcHeight = 2142;
  	var imageScale = .3;


  	var imageWidth = srcWidth * imageScale;
  	var imageHeight = srcHeight * imageScale;



  	var paper = Raphael("mapelem", imageWidth, imageHeight);
  	$("#mapelem").height(imageHeight).width(imageWidth);


  	var editfocus = false;

	var papermapimage;
  	
	var mode = "circlecreating"; // linedrawing , circledragging, circlecreating

	var currentCircle = false;
	var selectedCircle = false;
	var currentLine = false;
	var selectedLine = false;



	setupPaperImage(imageurl);


	// load list of graphfiles:
	$.ajax({
		url : "/?action=getgraphlist" ,
		contentType : 'application/json',
  		success : function(rdata, status){
  			console.log("success");
  			console.log(rdata);
  			$.each(rdata, function(index, filedata){
  				var string = filedata.file + " : " + filedata.stat.mtime;
  				$("#fileselect").append("<option value='"+filedata.file+"'>"+string+"</option>");
  			});
  		},

  		error : function(jqXHR, status, message){
  			console.log("error ");
  			console.log(status);
  			console.log(message);
  		}
	});

	$("#loadbutton").click(function(evt){
		var filename = $("#fileselect").val();
		if(!filename || filename == ''){
			return;
		}
		$.ajax({
			url : "/?action=loadgraph&dataFile="+filename ,
			contentType : 'application/json',
	  		success : function(rdata, status){
	  			console.log("success");
	  			console.log(rdata);
	  			clearGraph();
	  			setupPaperImage(imageurl);
	  			loadGraph(rdata);
	  		},

	  		error : function(jqXHR, status, message){
	  			console.log("error ");
	  			console.log(status);
	  			console.log(message);
	  		}
		});		

	});


	$("#load").click(function(){
		console.log("loading graph");


	});

	$("#save").click(function(){
		console.log("saving graph");
		var data = {nodes : {}, edges : {}};
		paper.forEach(function(elem){
			console.log(elem);
			if(elem.type == "circle"){
				var x = elem.attr("cx");
				var y = elem.attr("cy");
				var name = x + "_" + y;				
				console.log("circle " + name);
				var ndata = {x : x, 
					y: y,
					lightlevel : elem.data("lightlevel")
				};
				data.nodes[name] = ndata;
			}else if(elem.type == "path"){
				var sx = elem.data("startCircle").attr("cx");
				var sy = elem.data("startCircle").attr("cy");
				var ex = elem.data("endCircle").attr("cx");
				var ey = elem.data("endCircle").attr("cy");
				var sc_name = sx+"_"+sy;
				var ec_name = ex+"_"+ey;
				var name = sx+"_"+sy+":"+ex +"_"+ey;
				var edata = {sx : sx , 
							sy : sy , 
							ex :ex , 
							ey: ey, 
							startNode : sc_name , 
							endNode : ec_name,
							stairs : elem.data("stairs")
						};
				console.log("path " + name);
				data.edges[name] = edata;
			}
		});
		// save data to server
		var ajax_data = {graph: JSON.stringify(data)};
		$.ajax({
			url : "/?action=savegraph" ,
			data : ajax_data,
			contentType : 'application/json',
	  		success : function(rdata, status){
	  			console.log("success");
	  			console.log(rdata);
	  		},

	  		error : function(jqXHR, status, message){
	  			console.log("error ");
	  			console.log(status);
	  			console.log(message);
	  		}
		});		
	});




	function setupPaperImage(imageurl){

		papermapimage = paper.image(imageurl, 0,0, imageWidth, imageHeight);


		papermapimage.dblclick(function(evt){
			// switched to using corresponding events on #mapelem div
		});	

		papermapimage.click(function (evt){
			// switched to using corresponding events on #mapelem div
		});

		$("#mapelem").dblclick(function(evt){

		    var x  = (evt.offsetX || evt.clientX - $(evt.target).offset().left);
		    var y  = (evt.offsetY || evt.clientY - $(evt.target).offset().top);
			if(mode == "circlecreating"){
				// start drawing mode
				mode = "linedrawing";
				unsetSelectedCircle();
				var circle = createCircle(x,y);
				startLine(circle);
			}else if(mode == "linedrawing"){
				unsetSelectedCircle();
				var circle = createCircle(x,y);
				endLine(circle);
				// end linedrawing mode, go back to circlecreating mode 
				mode = "circlecreating";
			}


		});
		$("#mapelem").click(function(evt){

		    var x  = (evt.offsetX || evt.clientX - $(evt.target).offset().left);
		    var y  = (evt.offsetY || evt.clientY - $(evt.target).offset().top);

		    if(mode == "linedrawing"){
		    	// create new circle, end line at new circle, start new line at circle
		    	circle = createCircle(x,y);
		    	endLine(circle);
		    	startLine(circle);
			}
		});

		$(window).keypress(function (evt){
	       	if(evt.charCode == 100 && selectedCircle && !editfocus){ 
	       	// 'd' is pressed 
	       	// now, if someone is editing a form, this will have no effect.

	       		destroyCircle(selectedCircle);
	       	}
	       	if(evt.charCode == 100 && selectedLine && !editfocus){ // 'd' is pressed
	       		destroyLine(selectedLine);
	       	}

		});

		papermapimage.mousemove(function (evt){
			if(mode == "linedrawing"){
			    var x  = (evt.offsetX || evt.clientX - $(evt.target).offset().left);
			    var y  = (evt.offsetY || evt.clientY - $(evt.target).offset().top);

			    var sx = currentLine.attrs.path[0][1];
			    var sy = currentLine.attrs.path[0][2];

			    currentLine.attr("path", [["M",sx,sy],["L",x,y]]);

			}
		});
	}

	function clearGraph(){
		// ikes, this doesn't seem to work yet...
		paper.clear();
/*
		paper.forEach(function(elem){
			console.log(elem);
			if(elem.type == "circle" || elem.type == "path"){
				elem.remove();
			}
		});
*/
	}

	function loadGraph(graph){
		$.each(graph.nodes, function(index, node){
			var circle = createCircle(node.x, node.y);
			console.log(circle.data("lines"));
			console.log(circle.data());
			console.log(circle.data("lines"));
			console.log(circle.data("linesx"));
			$.each(node, function(index, value){
				circle.data(index, value);
			});
			console.log(circle.data());

		});

		// still problems with lines...
		$.each(graph.edges, function(index, edge){
			var line = createLine(edge.sx, edge.sy, edge.ex, edge.ey);
			var startCircle = paper.getById(edge.sx+"_"+edge.sy);
			var endCircle  = paper.getById(edge.ex+"_"+edge.ey);
			line.id = startCircle.id + ":" + endCircle.id;
			line.data("startCircle", startCircle);
			line.data("endCircle", endCircle);
			console.log(startCircle.data());
			startCircle.data("lines").push(line);
			endCircle.data("lines").push(line);
			$.each(edge, function(index, value){
				line.data(index, value);
			});
		});

	}

	function createCircle(x, y){
		// make a circle

		var circle = paper.circle(x,y, 5);
		circle.id  = x +"_"+y;

		currentCircle = circle;

		circle.data("lines", []);

		circle.attr("stroke","#f00");
		circle.attr("stroke-width",1);
		circle.attr("fill", "#5f5");
		circle.attr("fill-opacity",".2");
		circle.click(function(evt2){
		    if (evt2.stopPropagation) {
		    	console.log("no propagate");
		      evt2.stopPropagation();
		    }
		    //IE8 and Lower
		    else {
		    	console.log("no propagate");
		      evt2.cancelBubble = true;
		    }


			// click to select circle
			if(mode == "linedrawing"){
				if(currentCircle != this){
					unsetSelectedCircle();
					endLine(this);
					currentCircle = this;
					startLine(this);
				}
			}else if (mode == "circlecreating"){
				// circle is selected
				unsetSelectedCircle();
				setSelectedCircle(this);
			}
			selectedCircle = this;
		});
		circle.dblclick(function(evt3){

			   //IE9 & Other Browsers
		    if (evt3.stopPropagation) {
		      evt3.stopPropagation();
		    }
		    //IE8 and Lower
		    else {
		      evt3.cancelBubble = true;
		    }
			// dblclick to start drawing mode.
			if(mode == "linedrawing" && this == currentCircle){
				// end drawing mode, destroy current line
				unsetSelectedCircle();
				destroyLine(currentLine);
				mode = "circlecreating";
			}else{
				unsetSelectedCircle();
				mode = "linedrawing";
				currentCircle = this;
				startLine(currentCircle);
			}

		});

		circle.mouseover(function(evt){
			if(this != selectedCircle){
				this.attr("stroke","#0f0");
				this.attr("stroke-width",3);
				this.attr("fill", "#f5f");
				this.attr("fill-opacity",".4");
			}
		});
		circle.mouseout(function(evt){
			if (this != selectedCircle){
				this.attr("stroke","#f00");
				this.attr("stroke-width",1);
				this.attr("fill", "#5f5");
				this.attr("fill-opacity",".2");
			}
		});


		var cstartx;
		var cstarty;

		circle.drag(

			function(dx,dy, x,y){

				$("#debug").text(dx+", "+ dy);

				vx = cstartx + dx;
				vy = cstarty + dy;
				circle.attr("cx", vx);
				circle.attr("cy", vy);

				updateCirclePosition(this, vx, vy);
			 },
			 function(){
			 	cstartx = circle.attr("cx");
			 	cstarty = circle.attr("cy");
			 	/*
				$(".facetag").css("border","none");
				$("#faces"+index).css("border","2px solid black");
				$("#faces"+index).css("border-radius","5px");
				*/
			 }, 
			 function (evt) {


			  }
		);

		return circle;

	}


	function updateCirclePosition(circle, newX, newY){
		

		var deleteMe = false;
		
		$.each(circle.data("lines"), function(index, line){

			if(!line){
				return true;
			}

			var sx= line.attrs.path[0][1];
			var sy= line.attrs.path[0][2];
			var ex= line.attrs.path[1][1];
			var ey= line.attrs.path[1][2];

			var pathString;
			if(circle == line.data("startCircle")){

			    line.attr("path", [["M",newX,newY],["L",ex,ey]]);

			}else {

			    line.attr("path", [["M",sx,sy],["L",newX,newY]]);

			}
		});
	}


	function createLine(sx, sy, ex, ey){
		var pathString = "M"+sx+","+sy+"L"+ex+","+ey;
		var line = paper.path(pathString);

		line.attr("stroke","#000");
		line.attr("stroke-width",1);

		line.click(function(evt){
			if(mode == "circlecreating"){
				setSelectedLine(this);
			}
		});

		line.mouseover(function(){
			if(mode == "circlecreating"){
				if(line != selectedLine){
					this.attr("stroke-width", 2);
					this.attr("stroke", "#00f");
				}
			}
		});
		line.mouseout(function(){
			if(mode == "circlecreating"){
				if(line != selectedLine){
					line.attr("stroke","#000");
					line.attr("stroke-width",1);		
				}	
			}
		});
		return line;

	}

	function startLine(circle){
		// start current line at current circle
		var sx = circle.attrs.cx;
		var sy = circle.attrs.cy;

		var line = createLine(sx, sy, sx, sy);

		line.data("startCircle", circle);
		circle.data("lines").push(line);

		currentLine = line;

	}

	function endLine(circle){
		// end current line at current circle

		if(currentLine.data("startCircle") != circle){

			var ex = circle.attrs.cx ;
			var ey = circle.attrs.cy ;

		    var sx = currentLine.attrs.path[0][1];
		    var sy = currentLine.attrs.path[0][2];

		    currentLine.attr("path", [["M",sx,sy],["L",ex,ey]]);

			currentLine.data("endCircle", circle);
			circle.data("lines").push(currentLine);
			currentLine = false;
		}

	}

	function setSelectedCircle(circle){
		unsetSelectedLine();
		selectedCircle = circle;
		selectedCircle.attr("stroke","#00f");
		selectedCircle.attr("stroke-width",4);
		selectedCircle.attr("fill", "#f5f");
		selectedCircle.attr("fill-opacity",".4");


		$("#edit").empty();
		var deletenode = $("<span>Delete</span>").appendTo("#edit").click(function(){
			destroyCircle(circle);
			$("#edit").empty();			
		});

		var form = $("<form>").appendTo("#edit");
		form.append("<span>Gallery Number:</span><input type='text' name='gallery' size='5' /><BR>");
		var select = $("<span>Light Level:</span><select name='lightlevel'><BR>").appendTo(form);
		select.append("<option value=''>Select Light Level...</option>")
		select.append("<option value='low'>low</option>")
		.append("<option value='medium'>medium</option>")
		.append("<option value='high'>high</option>");
		form.change(function(evt){
			circle.data("lightlevel", $("select[name=lightlevel]", this). val());
		});
		$(":input" ,form).focus(function(){
			editfocus = true;
		});
		$(":input" ,form).blur(function(){
			editfocus = false;
		});

	}

	function unsetSelectedCircle(){
		if(selectedCircle){
			selectedCircle.attr("stroke","#f00");
			selectedCircle.attr("stroke-width",1);
			selectedCircle.attr("fill", "#5f5");
			selectedCircle.attr("fill-opacity",".2");

			selectedCircle = false;
		}
	}

	function setSelectedLine(line){
		unsetSelectedCircle();
		unsetSelectedLine();

		line.attr("stroke","#0f0");
		line.attr("stroke-width",2);

		selectedLine = line;

		// set selected line form
		$("#edit").empty();
		var deletenode = $("<span>Delete</span>").appendTo("#edit").click(function(){
			destroyLine(line);
			$("#edit").empty();
		});

		var form = $("<form>").appendTo("#edit");
		var checkbox = $("<span>Stairs : </span><input type='checkbox' class='stairs' name='stairs' value='true' label='stairs'>").appendTo(form);

		form.change(function(evt){
			line.data("stairs", $(".stairs", this)[0].checked);
		});

		$(":input" ,form).focus(function(){
			editfocus = true;
		});
		$(":input" ,form).blur(function(){
			editfocus = false;
		});


	}

	function unsetSelectedLine(){


		if(selectedLine){
			selectedLine.attr("stroke","#000");
			selectedLine.attr("stroke-width",1);
			selectedLine = false;
		}
	}

	function destroyCircle(circle){
		$.each(circle.data("lines"), function(index, line){
			destroyLine(line);
		});
		if(circle == selectedCircle){
			unsetSelectedLine();
		}
		circle.remove();
	}

	function destroyLine(line){
		if(!line){
			return;
		}
		// need to remove the line from all circles as well.
		removeLineFromCircles(line);
		if(line == selectedLine){
			unsetSelectedLine();
		}
		line.remove();
	}

	function removeLineFromCircles(line){
		if(!line){
			return;
		}
		var startIndexToRemove;
		if(line.data("startCircle")){
			$.each(line.data("startCircle").data("lines"), function (index, itsLine){
			if(itsLine == line){
					startIndexToRemove = index;
				}
			});
		}
		var endIndexToRemove = false;
		if(line.data("endCircle")){
			$.each(line.data("endCircle").data("lines"), function (index, itsLine){
				if(itsLine == line){
					endIndexToRemove = index;
				}
			});
		}
		if(endIndexToRemove){
			var lines = line.data("endCircle").data("lines");
			delete lines[endIndexToRemove];
		}

		if(startIndexToRemove){
			var lines = line.data("startCircle").data("lines");
			delete lines[startIndexToRemove];
		}

	}

});

</script>

</head>		
<body>
<BR><BR>

	<div class="container">
		<div class="row-fluid-banner">
			<div class="span4" align="left"><h1>PathFinder MapMaker </h1></div>
			<div class="span2" align="center">
				<span id="save"><B>Save Data</b></span>
			</div>
			<div class="span4" align="right">
				<form id="loadform"><select id="fileselect" name="filename"><option value="">Select File To Load...</option></select><span id="loadbutton"><B>Load</b></span>
			</div>
		</div>

		<div class="row-fluid-banner" >
			<div class="span6" id="mapelem"  width="400" height="600" ></div>
			<div class="span4" id="mapmetadata">
				<div id="debug">debug</div>
				<div id="edit">edit</div>
			</div>
		</div>

		<div class="row-fluid-banner" >
			<div class="span12" id="summarydata">summary</div>
		</div>

	</div>



</body>
</html>
