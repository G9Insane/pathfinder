<html>
<head>
<title>MapMaker</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<!-- Bootstrap -->
<link href="css/bootstrap.min.css" rel="stylesheet" media="screen">
<script src="js/jquery-1.10.2.min.js"></script>
<script type="text/javascript" src="js/raphael-min.js"></script>

<script language='javascript'>
/* behaviour:
if mouse is double-clicked in map: make a circle, 
- when moouse moves from click, make a line
- with each click, drop a new circle, with line ending at that circle, and starting a new line
- unless a circle is already there. in which case, connect the line to the existing circle, and keep going
- stop this mode when mouse is double-clicked.
-- if double-clicked on a circle, end line on that circle
-- if double-clicked in empty space, destroy that last line.
- drag on circle to move it. 
- click on circle to select
-- 'd' deletes selected circle, and all connected lines
- click on line to select it
-- 'd' deletes selected line


*/
$( document ).ready(function() {
  	var paper = Raphael("mapelem", 400, 600);

  	var imageurl = "floor-plan_s.jpg";

	var papermapimage = paper.image(imageurl, 0,0, 400, 600);

  	
	var mode = "circlecreating"; // linedrawing , circledragging, circlecreating

	var currentCircle = false;
	var selectedCircle = false;
	var currentLine = false;
	var selectedLine = false;


	$("#load").click(function(){
		console.log("loading graph");
		$.ajax({
			url : "/?action=loadgraph" ,
			contentType : 'application/json',
	  		success : function(rdata, status){
	  			console.log("success");
	  			console.log(rdata);
	  			clearGraph();
	  			loadGraph(rdata);
	  		},

	  		error : function(jqXHR, status, message){
	  			console.log("error ");
	  			console.log(status);
	  			console.log(message);
	  		}
		});		


	});

	$("#save").click(function(){
		console.log("saving graph");
		var data = {nodes : {}, edges : {}};
		paper.forEach(function(elem){
			console.log(elem);
			if(elem.type == "circle"){
				var x = elem.attr("cx");
				var y = elem.attr("cy");
				var name = x + "_" + y;				
				console.log("circle " + name);
				var ndata = {x : x, y: y};
				data.nodes[name] = ndata;
			}else if(elem.type == "path"){
				var sx = elem.data("startCircle").attr("cx");
				var sy = elem.data("startCircle").attr("cy");
				var ex = elem.data("endCircle").attr("cx");
				var ey = elem.data("endCircle").attr("cy");
				var sc_name = sx+"_"+sy;
				var ec_name = ex+"_"+ey;
				var name = sx+"_"+sy+":"+ex +"_"+ey;
				var edata = {sx : sx , sy : sy , ex :ex , ey: ey, startNode : sc_name , endNode : ec_name};
				console.log("path " + name);
				data.edges[name] = edata;
			}
		});
		// save data to server
		var ajax_data = {graph: JSON.stringify(data)};
		$.ajax({
			url : "/?action=savegraph" ,
			data : ajax_data,
			contentType : 'application/json',
	  		success : function(rdata, status){
	  			console.log("success");
	  			console.log(rdata);
	  		},

	  		error : function(jqXHR, status, message){
	  			console.log("error ");
	  			console.log(status);
	  			console.log(message);
	  		}
		});		
	});

	papermapimage.dblclick(function(evt){
	    var x  = (evt.offsetX || evt.clientX - $(evt.target).offset().left);
	    var y  = (evt.offsetY || evt.clientY - $(evt.target).offset().top);
		if(mode == "circlecreating"){
			// start drawing mode
			mode = "linedrawing";
			unsetSelectedCircle();
			var circle = createCircle(x,y);
			startLine(circle);
		}else if(mode == "linedrawing"){
			unsetSelectedCircle();
			var circle = createCircle(x,y);
			endLine(circle);
			// end linedrawing mode, go back to circlecreating mode 
			mode = "circlecreating";
		}

	});	

	papermapimage.click(function (evt){
	    var x  = (evt.offsetX || evt.clientX - $(evt.target).offset().left);
	    var y  = (evt.offsetY || evt.clientY - $(evt.target).offset().top);

	    if(mode == "linedrawing"){
	    	// create new circle, end line at new circle, start new line at circle
	    	circle = createCircle(x,y);
	    	endLine(circle);
	    	startLine(circle);
		}
	});


	$(window).keypress(function (evt){
       	if(evt.charCode == 100 && selectedCircle){ // 'd' is pressed
       		destroyCircle(selectedCircle);
       	}
       	if(evt.charCode == 100 && selectedLine){ // 'd' is pressed
       		destroyLine(selectedLine);
       	}

	});

	papermapimage.mousemove(function (evt){
		if(mode == "linedrawing"){
		    var x  = (evt.offsetX || evt.clientX - $(evt.target).offset().left);
		    var y  = (evt.offsetY || evt.clientY - $(evt.target).offset().top);

		    var sx = currentLine.attrs.path[0][1];
		    var sy = currentLine.attrs.path[0][2];

		    currentLine.attr("path", [["M",sx,sy],["L",x,y]]);

		}
	});


	function clearGraph(){
		paper.forEach(function(elem){
			console.log(elem);
			if(elem.type == "circle" || elem.type == "path"){
				elem.remove();
			}
		});
	}

	function loadGraph(graph){
		$.each(graph.nodes, function(index, node){
			var circle = createCircle(node.x, node.y);
			console.log(circle.data("lines"));
			console.log(circle.data());
			console.log(circle.data("lines"));
			console.log(circle.data("linesx"));
			$.each(node, function(index, value){
				circle.data(index, value);
			});
			console.log(circle.data());

		});
		$.each(graph.edges, function(index, edge){
			var line = createLine(edge.sx, edge.sy, edge.ex, edge.ey);
			var startCircle = paper.getById(edge.sx+"_"+edge.sy);
			var endCircle  = paper.getById(edge.ex+"_"+edge.ey);
			line.id = startCircle.id + ":" + endCircle.id;
			line.data("startCircle", startCircle);
			line.data("endCircle", endCircle);
			console.log(startCircle.data());
			startCircle.data("lines").push(line);
			endCircle.data("lines").push(line);
			$.each(edge, function(index, value){
				line.data(index, value);
			});
		});

	}

	function createCircle(x, y){
		// make a circle

		var circle = paper.circle(x,y, 5);
		circle.id  = x +"_"+y;

		currentCircle = circle;

		circle.data("lines", []);

		circle.attr("stroke","#f00");
		circle.attr("stroke-width",1);
		circle.attr("fill", "#5f5");
		circle.attr("fill-opacity",".2");
		circle.click(function(evt2){
			// click to select circle
			if(mode == "linedrawing"){
				if(currentCircle != this){
					unsetSelectedCircle();
					endLine(this);
					currentCircle = this;
					startLine(this);
				}
			}else if (mode == "circlecreating"){
				// circle is selected
				unsetSelectedCircle();
				setSelectedCircle(this);
			}
			selectedCircle = this;
		});
		circle.dblclick(function(evt3){
			// dblclick to start drawing mode.

			if(mode == "linedrawing" && this == currentCircle){
				// end drawing mode, destroy current line
				unsetSelectedCircle();
				destroyLine(currentLine);
				mode = "circlecreating";
			}else{
				unsetSelectedCircle();
				mode = "linedrawing";
				currentCircle = this;
				startLine(currentCircle);
			}

		});

		circle.mouseover(function(evt){
			if(this != selectedCircle){
				this.attr("stroke","#0f0");
				this.attr("stroke-width",3);
				this.attr("fill", "#f5f");
				this.attr("fill-opacity",".4");
			}
		});
		circle.mouseout(function(evt){
			if (this != selectedCircle){
				this.attr("stroke","#f00");
				this.attr("stroke-width",1);
				this.attr("fill", "#5f5");
				this.attr("fill-opacity",".2");
			}
		});


		var cstartx;
		var cstarty;

		circle.drag(

			function(dx,dy, x,y){

				$("#debug").text(dx+", "+ dy);

				vx = cstartx + dx;
				vy = cstarty + dy;
				circle.attr("cx", vx);
				circle.attr("cy", vy);

				updateCirclePosition(this, vx, vy);
			 },
			 function(){
			 	cstartx = circle.attr("cx");
			 	cstarty = circle.attr("cy");
			 	/*
				$(".facetag").css("border","none");
				$("#faces"+index).css("border","2px solid black");
				$("#faces"+index).css("border-radius","5px");
				*/
			 }, 
			 function (evt) {


			  }
		);

		return circle;

	}


	function updateCirclePosition(circle, newX, newY){
		

		var deleteMe = false;
		
		$.each(circle.data("lines"), function(index, line){

			if(!line){
				return true;
			}

			var sx= line.attrs.path[0][1];
			var sy= line.attrs.path[0][2];
			var ex= line.attrs.path[1][1];
			var ey= line.attrs.path[1][2];

			var pathString;
			if(circle == line.data("startCircle")){

			    line.attr("path", [["M",newX,newY],["L",ex,ey]]);

			}else {

			    line.attr("path", [["M",sx,sy],["L",newX,newY]]);

			}
		});
	}


	function createLine(sx, sy, ex, ey){
		var pathString = "M"+sx+","+sy+"L"+ex+","+ey;
		var line = paper.path(pathString);

		line.attr("stroke","#000");
		line.attr("stroke-width",1);

		line.click(function(evt){
			if(mode == "circlecreating"){
				setSelectedLine(this);
			}
		});

		line.mouseover(function(){
			if(mode == "circlecreating"){
				if(line != selectedLine){
					this.attr("stroke-width", 2);
					this.attr("stroke", "#00f");
				}
			}
		});
		line.mouseout(function(){
			if(mode == "circlecreating"){
				if(line != selectedLine){
					line.attr("stroke","#000");
					line.attr("stroke-width",1);		
				}	
			}
		});
		return line;

	}

	function startLine(circle){
		// start current line at current circle
		var sx = circle.attrs.cx;
		var sy = circle.attrs.cy;

		var line = createLine(sx, sy, sx, sy);

		line.data("startCircle", circle);
		circle.data("lines").push(line);

		currentLine = line;

	}

	function endLine(circle){
		// end current line at current circle

		if(currentLine.data("startCircle") != circle){

			var ex = circle.attrs.cx ;
			var ey = circle.attrs.cy ;

		    var sx = currentLine.attrs.path[0][1];
		    var sy = currentLine.attrs.path[0][2];

		    currentLine.attr("path", [["M",sx,sy],["L",ex,ey]]);

			currentLine.data("endCircle", circle);
			circle.data("lines").push(currentLine);
			currentLine = false;
		}

	}

	function setSelectedCircle(circle){
		unsetSelectedLine();
		selectedCircle = circle;
		selectedCircle.attr("stroke","#00f");
		selectedCircle.attr("stroke-width",4);
		selectedCircle.attr("fill", "#f5f");
		selectedCircle.attr("fill-opacity",".4");
	}

	function unsetSelectedCircle(){
		if(selectedCircle){
			selectedCircle.attr("stroke","#f00");
			selectedCircle.attr("stroke-width",1);
			selectedCircle.attr("fill", "#5f5");
			selectedCircle.attr("fill-opacity",".2");

			selectedCircle = false;
		}
	}

	function setSelectedLine(line){
		unsetSelectedCircle();
		unsetSelectedLine();

		line.attr("stroke","#0f0");
		line.attr("stroke-width",2);

		selectedLine = line;

	}

	function unsetSelectedLine(){


		if(selectedLine){
			selectedLine.attr("stroke","#000");
			selectedLine.attr("stroke-width",1);
			selectedLine = false;
		}
	}

	function destroyCircle(circle){
		$.each(circle.data("lines"), function(index, line){
			destroyLine(line);
		});
		if(circle == selectedCircle){
			unsetSelectedLine();
		}
		circle.remove();
	}

	function destroyLine(line){
		console.log("destroying line");
		// need to remove the line from all circles as well.
		removeLineFromCircles(line);
		if(line == selectedLine){
			unsetSelectedLine();
		}
		line.remove();
	}

	function removeLineFromCircles(line){
		if(!line){
			return;
		}
		var startIndexToRemove;
		if(line.data("startCircle")){
			$.each(line.data("startCircle").data("lines"), function (index, itsLine){
			if(itsLine == line){
					startIndexToRemove = index;
				}
			});
		}
		var endIndexToRemove = false;
		if(line.data("endCircle")){
			$.each(line.data("endCircle").data("lines"), function (index, itsLine){
				if(itsLine == line){
					endIndexToRemove = index;
				}
			});
		}
		if(endIndexToRemove){
			var lines = line.data("endCircle").data("lines");
			delete lines[endIndexToRemove];
		}

		if(startIndexToRemove){
			var lines = line.data("startCircle").data("lines");
			delete lines[startIndexToRemove];
		}

	}

});

</script>

</head>		
<body>


	<div class="container">
		<div class="row-fluid-banner">
			<div class="span6" align="left"><h1>PathFinder MapMaker (<span id="save">Save Data</span>)(<span id="load">Load Data</span>)</h1></div>
		</div>

		<div class="row-fluid-banner" >
			<div class="span6" id="mapelem"  width="400" height="600" ></div>
			<div class="span4" id="mapmetadata">
				<div id="debug">debug</div>
			</div>
		</div>

		<div class="row-fluid-banner" >
			<div class="span12" id="summarydata"></div>
		</div>

	</div>



</body>
</html>
